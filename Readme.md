# گزارش تمرین پروفایلینگ و بهینه‌سازی 

## ۱. بخش اول

### مراحل کشف مشکل 
برای ریشه‌یابی دقیق خطا، مراحل زیر با استفاده از ابزار YourKit انجام شد:

1.  اجرا و بازسازی خطا: برنامه با استفاده از پلاگین YourKit در IntelliJ اجرا شد. پس از وارد کردن اعداد ورودی، برنامه وارد وضعیت پردازش سنگین (Freeze) شد.
2.  ضبط داده‌ها : در لحظه‌ی کندی برنامه، دکمه Start CPU Recording در پروفایلر فشرده شد تا رفتار برنامه در زمان واقعی ضبط شود. در نهایت capture performance snapshot برای ضبط اسنپ شات زده شد
3.  تحلیل نمودارها :
    *   با بررسی نمودار CPU Usage ، مشاهده شد که پردازنده درگیر محاسبات سنگین می شود.
    ![alt text](Images/CPU1.png)

    *   با مراجعه به تب Hot Spots ، متد temp() در صدر لیست قرار داشت که نشان می‌داد عمده منابع سیستم در این نقطه مصرف می‌شود.
    ![alt text](Images/Hotspot1.png)

### تحلیل علت 
اگر به فایل JavaCup.java نگاه کنید، متد temp اینگونه است:

``` java
public static void temp() {
    ArrayList a = new ArrayList();
    for (int i = 0; i < 10000; i++) // ۱۰ هزار بار
    {
        for (int j = 0; j < 20000; j++) { // ۲۰ هزار بار
            a.add(i + j);
        }
    }
}
```

این حلقه 
10,000×20,000=200,000,000
 بار اجرا می‌شوند
یعنی برنامه سعی می‌کند دویست میلیون عدد را در حافظه ذخیره کند. این کار هم CPU را درگیر می‌کند (برای محاسبه و add کردن) و هم رم (RAM) را پر می‌کند و باعث می‌شود Garbage Collector مدام فعال شود و برنامه عملاً قفل کند.


### راه حل 

از آنجا که لیست a یک متغیر محلی است و هیچ‌گاه از آن استفاده نمی‌شود (Dead Code)،می توان آن را حذف کرد و فقط حاصل جمع را محاسبه کرد(حتی این را هم می توان حذف کرد) البته کل تابع temp  بی فایده است (تاثیری در خروجی ندارد) و می توان کل بدنه آن را حذف کرد اما از انجایی که در دستور کار ذکر شده که از صرف نظر کردن آن و موارد مشابه جلوگیری شود، برداشت من این بوده که حتما بدنه باید باشد و حلقه اجرا شود.


کد اصلاح شده
```java
public static void temp() {
        for (int i = 0; i < 10000; i++)
        {
            for (int j = 0; j < 20000; j++) {
                int calculation = i + j;             }
        }
    }
```
نتایج cpu و hotspot  بعد اعمال تغییرات به این شکل است
![alt text](Images/Hotspot2.png)
![alt text](Images/CPU2.png)


### ۲. بخش دوم (محاسبه اعداد اول)

برای این بخش، برنامه‌ای جهت شمارش تعداد اعداد اول تا محدوده 1000000 نوشته شد. مراحل تحلیل به شرح زیر است:

اجرای پروفایلینگ: کد اولیه که از الگوریتم ساده (تقسیم بر تمام اعداد کوچک‌تر) استفاده می‌کرد، اجرا و پروفایل شد.

مشاهده وضعیت Telemetry: در نمودار CPU Usage مشاهده شد که پردازنده برای مدت طولانی در ۱۰۰٪ توان خود قرار دارد.

شناسایی Hot Spot: در لیست Hot Spots، متد isPrime() با اختصاص ۹۹٪ از زمان اجرای کل برنامه به خود، به عنوان گلوگاه اصلی شناسایی شد.

تحلیل علت

کد اولیه به صورت زیر پیاده‌سازی شده بود:

``` java
public static boolean isPrime(int n) {
    for (int i = 2; i < n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

در این حالت، مرتبه اجرایی الگوریتم برای هر عدد $O(n)$ است. با توجه به اینکه این متد برای تمام اعداد تا 1000000 فراخوانی می‌شود، مجموع تکرارها بسیار بالا رفته و باعث اشغال طولانی‌مدت CPU می‌گردد.

![alt text](Images/CPU3.png)
![alt text](Images/Hotspot3.png)

راه حل

الگوریتم تشخیص عدد اول را بهینه‌سازی کردیم. به جای بررسی تمام اعداد تا $n$، کافیست تقسیم‌ را تا جذر عدد بررسی کنیم.

کد اصلاح شده
```java
public static boolean isPrimeOptimized(int n) {
    if (n <= 1) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false; 

    int boundary = (int) Math.sqrt(n);
    for (int i = 3; i <= boundary; i += 2) {
        if (n % i == 0) return false;
    }
    return true;
}
```

نتایج پس از بهینه‌سازی

پس از اعمال تغییرات و اجرای مجدد پروفایلر، نتایج زیر حاصل شد:

کاهش زمان اجرا: زمان اجرای متد اصلی از ۲۴ ثانیه به کمتر از ۴۰ میلی‌ثانیه کاهش یافت.

بهبود مصرف CPU: در نمودار Telemetry جدید، به دلیل سرعت بسیار بالای اجرا، دیگر قله‌ای در مصرف CPU مشاهده نمی‌شود و برنامه بلافاصله پایان می‌یابد.

تحلیل Hot Spot: متد isPrimeOptimized زمان مصرفی بسیار کمتری دارد.

این بهینه‌سازی باعث شد بدون تغییر در عملکرد کلی برنامه، کارایی آن بیش از ۶۰۰ برابر بهبود یابد.

![alt text](Images/CPU4.png)
![alt text](Images/Hotspot4.png)
